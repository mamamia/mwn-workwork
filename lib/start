#!/bin/bash

# Run commands in the background
# Credit: http://stackoverflow.com/a/15578203

kill_existing() {
  KILL_APPS=(
    'apache2'
    'nginx'
    'mysql'
    'grunt'
  )
  for APP in "${KILL_APPS[@]}"; do
    PID=$(ps aux | grep "${APP}" | grep -v grep | awk '{print $2}')
    if [[ $PID ]]; then
      sudo kill $PID &
    fi
  done
}

grunt_watch() {
  cd ${SITE_DIR}/bedrock && grunt watch &
}


# Run mwn-workwork proxy and database container, common for all sites
docker_compose_common(){
  # 1. Start docker-machine
  if [ $PLATFORM == "osx" ]; then
    docker-machine start dev 2>/dev/null
    eval $(docker-machine env dev)
  fi

  # 2. Check if proxy container is running
  if [[ "$(docker inspect -f {{.State.Running}} mwn-mysql)" == "true" ]]; then
    echo "Database is running, no need to run workwork docker-compose."
  else
    docker_compose $WW_DIR
    sleep 12

    # wait for the database container
    # sudo docker inspect --format '{{ .NetworkSettings.IPAddress }}:3306' workwork | xargs wget --retry-connrefused --tries=5 -q --wait=3 --spider
    # the following is not working on mac, also possible with nc -z database 3306
    #wget http://database:3306 --retry-connrefused --tries=5 -q --wait=2 --spider
    until [ "`docker inspect -f {{.State.Running}} mwn-mysql`" == "true" ]; do
      echo "...Waiting for container to start"
      sleep 2;
      wget http://database:3306 --retry-connrefused --tries=5 -q --wait=2 --spider
    done;
  fi

  # 3. Fire per-site container
  docker_compose $SITE_DIR
}

# Run per-site container
docker_compose() {
  if [ $PLATFORM == "osx" ]; then
    # & is better than -d, as logs are visible for debugging
    cd ${1}/docker && docker-compose up &
  else
    cd ${1}/docker && sudo docker-compose up &
  fi
}
